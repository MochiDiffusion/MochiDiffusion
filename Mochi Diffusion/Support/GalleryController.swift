//
//  GalleryController.swift
//  Mochi Diffusion
//
//  Created by Joshua Park on 2/12/23.
//

import SwiftUI
import UniformTypeIdentifiers
import os

@MainActor
@Observable
final class GalleryController {
    private let logger = Logger()
    var configStore: ConfigStore
    var isLoading = true
    private let imageRepository: ImageRepository
    private let focusController: FocusController

    private var imageFolderMonitorTask: Task<Void, Never>?
    private var imageDirDebounceTask: Task<Void, Never>?

    init(
        configStore: ConfigStore,
        imageRepository: ImageRepository = ImageRepository(),
        focusController: FocusController
    ) {
        self.configStore = configStore
        self.imageRepository = imageRepository
        self.focusController = focusController
        Task {
            await load()
        }
        startImageFolderMonitor()
        observeImageDir()
    }

    func load() async {
        isLoading = true
        await loadImages()
        isLoading = false
    }

    func loadImages() async {
        logger.info("Started loading images directory at: \"\(self.configStore.imageDir)\"")
        do {
            let records = try await imageRepository.load(
                imageDir: configStore.imageDir
            )
            let imagesAndMetadata = records.compactMap { record in
                createSDImage(from: record).map { image in
                    (image: image, metadataFields: record.metadataFields)
                }
            }
            let count = imagesAndMetadata.count

            logger.info("Found \(count) image(s)")

            ImageGallery.shared.replaceAll(imagesAndMetadata)
        } catch ImageRepositoryError.imageDirectoryNoAccess(let path) {
            logger.error("Couldn't access images directory at: \"\(path)\"")
        } catch {
            logger.error("There was a problem loading the images: \(error.localizedDescription)")
        }
    }

    func select(_ id: SDImage.ID) async {
        ImageGallery.shared.select(id)
        focusController.removeAllFocus()
    }

    func selectPrevious() async {
        guard let previous = ImageGallery.shared.imageBefore(ImageGallery.shared.selectedId) else {
            return
        }
        await select(previous)
    }

    func selectNext() async {
        guard let next = ImageGallery.shared.imageAfter(ImageGallery.shared.selectedId) else {
            return
        }
        await select(next)
    }

    func removeImage(_ sdi: SDImage) async {
        if sdi.id == ImageGallery.shared.selectedId {
            if let previous = ImageGallery.shared.imageBefore(sdi.id, wrap: false) {
                /// Move selection to the left, if possible.
                await select(previous)
            } else if let next = ImageGallery.shared.imageAfter(sdi.id, wrap: false) {
                /// When deleting the first image, move selection to the right.
                await select(next)
            }
        }

        ImageGallery.shared.remove(sdi)
        await imageRepository.delete(path: sdi.path, moveToTrash: configStore.useTrash)
    }

    func removeCurrentImage() async {
        guard let sdi = ImageGallery.shared.selected() else { return }
        await removeImage(sdi)
    }

    func importImages() async {
        let panel = NSOpenPanel()
        panel.allowedContentTypes = [.image]
        panel.allowsMultipleSelection = true
        panel.canCreateDirectories = false
        panel.canChooseDirectories = false
        panel.canChooseFiles = true
        panel.message = String(localized: "Choose generated images to import")
        panel.prompt = String(localized: "Import", comment: "OK button text for import image panel")
        let resp = await panel.beginSheetModal(for: NSApplication.shared.mainWindow!)
        if resp != .OK {
            return
        }

        let selectedURLs = panel.urls
        if selectedURLs.isEmpty { return }

        isLoading = true
        let (records, failed) = await imageRepository.importImages(
            from: selectedURLs, imageDir: configStore.imageDir)
        let imagesAndMetadata = records.compactMap { record in
            createSDImage(from: record).map { image in
                (image: image, metadataFields: record.metadataFields)
            }
        }
        let succeeded = imagesAndMetadata.count
        ImageGallery.shared.add(imagesAndMetadata)
        isLoading = false

        let alert = NSAlert()
        alert.messageText = String(localized: "Imported \(succeeded) image(s)")
        if failed > 0 {
            alert.informativeText = String(
                localized:
                    "\(failed) image(s) were not imported. Only images generated by Mochi Diffusion 2.2 or later can be imported."
            )
        }
        alert.alertStyle = .informational
        alert.addButton(withTitle: "OK")
        await alert.beginSheetModal(for: NSApplication.shared.mainWindow!)
    }

    func saveAll() async {
        if ImageGallery.shared.images.isEmpty { return }
        let panel = NSOpenPanel()
        panel.allowedContentTypes = [.image]
        panel.canCreateDirectories = true
        panel.canChooseDirectories = true
        panel.canChooseFiles = false
        panel.message = String(localized: "Choose a folder to save all images")
        panel.prompt = String(localized: "Save")
        let resp = await panel.beginSheetModal(for: NSApplication.shared.mainWindow!)
        if resp != .OK {
            return
        }

        guard let selectedURL = panel.url else { return }
        let type = UTType.fromString(configStore.imageType)

        let images = ImageGallery.shared.images
        var exportRequests: [ImageExportRequest] = []
        exportRequests.reserveCapacity(images.count)
        for (index, sdi) in images.enumerated() {
            let count = index + 1
            guard let data = await sdi.imageData(type) else { continue }
            exportRequests.append(
                ImageExportRequest(
                    filenameWithoutExtension: sdi.filenameWithoutExtension(count: count),
                    imageData: data
                )
            )
        }

        await imageRepository.exportAllImages(exportRequests, to: selectedURL, type: type)
    }

    func copyImage(_ sdi: SDImage) async {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        guard let imageData = await sdi.imageData(.png) else { return }
        guard let image = NSImage(data: imageData) else { return }
        pasteboard.writeObjects([image])
    }

    private func observeImageDir() {
        withObservationTracking {
            _ = configStore.imageDir
        } onChange: { [weak self] in
            Task { @MainActor in
                self?.scheduleImageDirUpdate()
                self?.observeImageDir()
            }
        }
    }

    private func scheduleImageDirUpdate() {
        imageDirDebounceTask?.cancel()
        imageDirDebounceTask = Task { @MainActor in
            do {
                try await Task.sleep(nanoseconds: 500_000_000)
            } catch {
                return
            }
            await updateImageFolderMonitor()
        }
    }

    private func updateImageFolderMonitor() async {
        startImageFolderMonitor()
        await loadImages()
    }

    private func startImageFolderMonitor() {
        imageFolderMonitorTask?.cancel()
        let path = imageDirectoryPath()
        imageFolderMonitorTask = Task { [weak self] in
            guard let self else { return }
            let stream = await FolderMonitorService.shared.updates(for: path)
            for await _ in stream {
                await self.syncImages()
            }
        }
    }

    private func imageDirectoryPath() -> String {
        ImageRepository.imageDirectoryURL(fromPath: configStore.imageDir)
            .path(percentEncoded: false)
    }

    private func syncImages() async {
        let imageDir = imageDirectoryPath()
        let existingPaths = ImageGallery.shared.allImages.compactMap { sdi in
            sdi.path.isEmpty ? nil : sdi.path
        }

        let result = await imageRepository.syncImages(
            imageDir: imageDir,
            existingPaths: existingPaths
        )

        if !result.additions.isEmpty {
            let additions = result.additions.compactMap { record in
                createSDImage(from: record).map { image in
                    (image: image, metadataFields: record.metadataFields)
                }
            }
            ImageGallery.shared.add(additions)
        }

        if !result.removals.isEmpty {
            let removals = ImageGallery.shared.allImages.filter {
                result.removals.contains($0.path)
            }
            ImageGallery.shared.remove(removals)
        }
    }
}
